// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"uno/domain/model"
	"uno/domain/ports"

	mock "github.com/stretchr/testify/mock"
)

// NewHappeningRepo creates a new instance of HappeningRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewHappeningRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *HappeningRepo {
	mock := &HappeningRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// HappeningRepo is an autogenerated mock type for the HappeningRepo type
type HappeningRepo struct {
	mock.Mock
}

type HappeningRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *HappeningRepo) EXPECT() *HappeningRepo_Expecter {
	return &HappeningRepo_Expecter{mock: &_m.Mock}
}

// CreateHappening provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) CreateHappening(ctx context.Context, happening model.Happening) (model.Happening, error) {
	ret := _mock.Called(ctx, happening)

	if len(ret) == 0 {
		panic("no return value specified for CreateHappening")
	}

	var r0 model.Happening
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.Happening) (model.Happening, error)); ok {
		return returnFunc(ctx, happening)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.Happening) model.Happening); ok {
		r0 = returnFunc(ctx, happening)
	} else {
		r0 = ret.Get(0).(model.Happening)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, model.Happening) error); ok {
		r1 = returnFunc(ctx, happening)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_CreateHappening_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateHappening'
type HappeningRepo_CreateHappening_Call struct {
	*mock.Call
}

// CreateHappening is a helper method to define mock.On call
//   - ctx context.Context
//   - happening model.Happening
func (_e *HappeningRepo_Expecter) CreateHappening(ctx interface{}, happening interface{}) *HappeningRepo_CreateHappening_Call {
	return &HappeningRepo_CreateHappening_Call{Call: _e.mock.On("CreateHappening", ctx, happening)}
}

func (_c *HappeningRepo_CreateHappening_Call) Run(run func(ctx context.Context, happening model.Happening)) *HappeningRepo_CreateHappening_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 model.Happening
		if args[1] != nil {
			arg1 = args[1].(model.Happening)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_CreateHappening_Call) Return(happening1 model.Happening, err error) *HappeningRepo_CreateHappening_Call {
	_c.Call.Return(happening1, err)
	return _c
}

func (_c *HappeningRepo_CreateHappening_Call) RunAndReturn(run func(ctx context.Context, happening model.Happening) (model.Happening, error)) *HappeningRepo_CreateHappening_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllHappenings provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetAllHappenings(ctx context.Context) ([]model.Happening, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllHappenings")
	}

	var r0 []model.Happening
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]model.Happening, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []model.Happening); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Happening)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetAllHappenings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllHappenings'
type HappeningRepo_GetAllHappenings_Call struct {
	*mock.Call
}

// GetAllHappenings is a helper method to define mock.On call
//   - ctx context.Context
func (_e *HappeningRepo_Expecter) GetAllHappenings(ctx interface{}) *HappeningRepo_GetAllHappenings_Call {
	return &HappeningRepo_GetAllHappenings_Call{Call: _e.mock.On("GetAllHappenings", ctx)}
}

func (_c *HappeningRepo_GetAllHappenings_Call) Run(run func(ctx context.Context)) *HappeningRepo_GetAllHappenings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetAllHappenings_Call) Return(happenings []model.Happening, err error) *HappeningRepo_GetAllHappenings_Call {
	_c.Call.Return(happenings, err)
	return _c
}

func (_c *HappeningRepo_GetAllHappenings_Call) RunAndReturn(run func(ctx context.Context) ([]model.Happening, error)) *HappeningRepo_GetAllHappenings_Call {
	_c.Call.Return(run)
	return _c
}

// GetHappeningById provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetHappeningById(ctx context.Context, id string) (model.Happening, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetHappeningById")
	}

	var r0 model.Happening
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (model.Happening, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) model.Happening); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(model.Happening)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetHappeningById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHappeningById'
type HappeningRepo_GetHappeningById_Call struct {
	*mock.Call
}

// GetHappeningById is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *HappeningRepo_Expecter) GetHappeningById(ctx interface{}, id interface{}) *HappeningRepo_GetHappeningById_Call {
	return &HappeningRepo_GetHappeningById_Call{Call: _e.mock.On("GetHappeningById", ctx, id)}
}

func (_c *HappeningRepo_GetHappeningById_Call) Run(run func(ctx context.Context, id string)) *HappeningRepo_GetHappeningById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetHappeningById_Call) Return(happening model.Happening, err error) *HappeningRepo_GetHappeningById_Call {
	_c.Call.Return(happening, err)
	return _c
}

func (_c *HappeningRepo_GetHappeningById_Call) RunAndReturn(run func(ctx context.Context, id string) (model.Happening, error)) *HappeningRepo_GetHappeningById_Call {
	_c.Call.Return(run)
	return _c
}

// GetHappeningHostGroups provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetHappeningHostGroups(ctx context.Context, happeningID string) ([]string, error) {
	ret := _mock.Called(ctx, happeningID)

	if len(ret) == 0 {
		panic("no return value specified for GetHappeningHostGroups")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return returnFunc(ctx, happeningID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = returnFunc(ctx, happeningID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, happeningID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetHappeningHostGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHappeningHostGroups'
type HappeningRepo_GetHappeningHostGroups_Call struct {
	*mock.Call
}

// GetHappeningHostGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - happeningID string
func (_e *HappeningRepo_Expecter) GetHappeningHostGroups(ctx interface{}, happeningID interface{}) *HappeningRepo_GetHappeningHostGroups_Call {
	return &HappeningRepo_GetHappeningHostGroups_Call{Call: _e.mock.On("GetHappeningHostGroups", ctx, happeningID)}
}

func (_c *HappeningRepo_GetHappeningHostGroups_Call) Run(run func(ctx context.Context, happeningID string)) *HappeningRepo_GetHappeningHostGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetHappeningHostGroups_Call) Return(strings []string, err error) *HappeningRepo_GetHappeningHostGroups_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *HappeningRepo_GetHappeningHostGroups_Call) RunAndReturn(run func(ctx context.Context, happeningID string) ([]string, error)) *HappeningRepo_GetHappeningHostGroups_Call {
	_c.Call.Return(run)
	return _c
}

// GetHappeningQuestions provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetHappeningQuestions(ctx context.Context, happeningID string) ([]model.Question, error) {
	ret := _mock.Called(ctx, happeningID)

	if len(ret) == 0 {
		panic("no return value specified for GetHappeningQuestions")
	}

	var r0 []model.Question
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]model.Question, error)); ok {
		return returnFunc(ctx, happeningID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []model.Question); ok {
		r0 = returnFunc(ctx, happeningID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Question)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, happeningID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetHappeningQuestions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHappeningQuestions'
type HappeningRepo_GetHappeningQuestions_Call struct {
	*mock.Call
}

// GetHappeningQuestions is a helper method to define mock.On call
//   - ctx context.Context
//   - happeningID string
func (_e *HappeningRepo_Expecter) GetHappeningQuestions(ctx interface{}, happeningID interface{}) *HappeningRepo_GetHappeningQuestions_Call {
	return &HappeningRepo_GetHappeningQuestions_Call{Call: _e.mock.On("GetHappeningQuestions", ctx, happeningID)}
}

func (_c *HappeningRepo_GetHappeningQuestions_Call) Run(run func(ctx context.Context, happeningID string)) *HappeningRepo_GetHappeningQuestions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetHappeningQuestions_Call) Return(questions []model.Question, err error) *HappeningRepo_GetHappeningQuestions_Call {
	_c.Call.Return(questions, err)
	return _c
}

func (_c *HappeningRepo_GetHappeningQuestions_Call) RunAndReturn(run func(ctx context.Context, happeningID string) ([]model.Question, error)) *HappeningRepo_GetHappeningQuestions_Call {
	_c.Call.Return(run)
	return _c
}

// GetHappeningRegistrationCounts provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetHappeningRegistrationCounts(ctx context.Context, happeningIDs []string) ([]ports.GroupedRegistrationCount, error) {
	ret := _mock.Called(ctx, happeningIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetHappeningRegistrationCounts")
	}

	var r0 []ports.GroupedRegistrationCount
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string) ([]ports.GroupedRegistrationCount, error)); ok {
		return returnFunc(ctx, happeningIDs)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string) []ports.GroupedRegistrationCount); ok {
		r0 = returnFunc(ctx, happeningIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ports.GroupedRegistrationCount)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = returnFunc(ctx, happeningIDs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetHappeningRegistrationCounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHappeningRegistrationCounts'
type HappeningRepo_GetHappeningRegistrationCounts_Call struct {
	*mock.Call
}

// GetHappeningRegistrationCounts is a helper method to define mock.On call
//   - ctx context.Context
//   - happeningIDs []string
func (_e *HappeningRepo_Expecter) GetHappeningRegistrationCounts(ctx interface{}, happeningIDs interface{}) *HappeningRepo_GetHappeningRegistrationCounts_Call {
	return &HappeningRepo_GetHappeningRegistrationCounts_Call{Call: _e.mock.On("GetHappeningRegistrationCounts", ctx, happeningIDs)}
}

func (_c *HappeningRepo_GetHappeningRegistrationCounts_Call) Run(run func(ctx context.Context, happeningIDs []string)) *HappeningRepo_GetHappeningRegistrationCounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetHappeningRegistrationCounts_Call) Return(groupedRegistrationCounts []ports.GroupedRegistrationCount, err error) *HappeningRepo_GetHappeningRegistrationCounts_Call {
	_c.Call.Return(groupedRegistrationCounts, err)
	return _c
}

func (_c *HappeningRepo_GetHappeningRegistrationCounts_Call) RunAndReturn(run func(ctx context.Context, happeningIDs []string) ([]ports.GroupedRegistrationCount, error)) *HappeningRepo_GetHappeningRegistrationCounts_Call {
	_c.Call.Return(run)
	return _c
}

// GetHappeningRegistrations provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetHappeningRegistrations(ctx context.Context, happeningID string) ([]ports.HappeningRegistration, error) {
	ret := _mock.Called(ctx, happeningID)

	if len(ret) == 0 {
		panic("no return value specified for GetHappeningRegistrations")
	}

	var r0 []ports.HappeningRegistration
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]ports.HappeningRegistration, error)); ok {
		return returnFunc(ctx, happeningID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []ports.HappeningRegistration); ok {
		r0 = returnFunc(ctx, happeningID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ports.HappeningRegistration)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, happeningID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetHappeningRegistrations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHappeningRegistrations'
type HappeningRepo_GetHappeningRegistrations_Call struct {
	*mock.Call
}

// GetHappeningRegistrations is a helper method to define mock.On call
//   - ctx context.Context
//   - happeningID string
func (_e *HappeningRepo_Expecter) GetHappeningRegistrations(ctx interface{}, happeningID interface{}) *HappeningRepo_GetHappeningRegistrations_Call {
	return &HappeningRepo_GetHappeningRegistrations_Call{Call: _e.mock.On("GetHappeningRegistrations", ctx, happeningID)}
}

func (_c *HappeningRepo_GetHappeningRegistrations_Call) Run(run func(ctx context.Context, happeningID string)) *HappeningRepo_GetHappeningRegistrations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetHappeningRegistrations_Call) Return(happeningRegistrations []ports.HappeningRegistration, err error) *HappeningRepo_GetHappeningRegistrations_Call {
	_c.Call.Return(happeningRegistrations, err)
	return _c
}

func (_c *HappeningRepo_GetHappeningRegistrations_Call) RunAndReturn(run func(ctx context.Context, happeningID string) ([]ports.HappeningRegistration, error)) *HappeningRepo_GetHappeningRegistrations_Call {
	_c.Call.Return(run)
	return _c
}

// GetHappeningSpotRanges provides a mock function for the type HappeningRepo
func (_mock *HappeningRepo) GetHappeningSpotRanges(ctx context.Context, happeningID string) ([]model.SpotRange, error) {
	ret := _mock.Called(ctx, happeningID)

	if len(ret) == 0 {
		panic("no return value specified for GetHappeningSpotRanges")
	}

	var r0 []model.SpotRange
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]model.SpotRange, error)); ok {
		return returnFunc(ctx, happeningID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []model.SpotRange); ok {
		r0 = returnFunc(ctx, happeningID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.SpotRange)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, happeningID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// HappeningRepo_GetHappeningSpotRanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHappeningSpotRanges'
type HappeningRepo_GetHappeningSpotRanges_Call struct {
	*mock.Call
}

// GetHappeningSpotRanges is a helper method to define mock.On call
//   - ctx context.Context
//   - happeningID string
func (_e *HappeningRepo_Expecter) GetHappeningSpotRanges(ctx interface{}, happeningID interface{}) *HappeningRepo_GetHappeningSpotRanges_Call {
	return &HappeningRepo_GetHappeningSpotRanges_Call{Call: _e.mock.On("GetHappeningSpotRanges", ctx, happeningID)}
}

func (_c *HappeningRepo_GetHappeningSpotRanges_Call) Run(run func(ctx context.Context, happeningID string)) *HappeningRepo_GetHappeningSpotRanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *HappeningRepo_GetHappeningSpotRanges_Call) Return(spotRanges []model.SpotRange, err error) *HappeningRepo_GetHappeningSpotRanges_Call {
	_c.Call.Return(spotRanges, err)
	return _c
}

func (_c *HappeningRepo_GetHappeningSpotRanges_Call) RunAndReturn(run func(ctx context.Context, happeningID string) ([]model.SpotRange, error)) *HappeningRepo_GetHappeningSpotRanges_Call {
	_c.Call.Return(run)
	return _c
}
